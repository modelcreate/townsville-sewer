{"version":3,"sources":["components/Deck/index.tsx","utils/tracer/index.ts","utils/PathCreator/index.ts","components/App/index.tsx","serviceWorker.ts","index.tsx"],"names":["Tracer","nodes","pipes","Object","classCallCheck","this","lookup","allFeatures","features","concat","reduce","obj","item","properties","id","path","looking","geo","found","length","geometry","nextObjId","ds","push","type","coordinates","forEach","coor","PathCreator","sewerFlow","startValue","accumulator","currentValue","currentIndex","orgPath","previousCoord","from","point","to","dist","distance","units","timeToArrive","initialViewState","longitude","latitude","zoom","pitch","bearing","trace","nodeData","pipeData","i","rndFeature","Math","floor","random","sewerPathTime","find","Deck","state","time","_animationFrame","_animate","window","cancelAnimationFrame","timeStamp","_this$props","props","loopLength","animationSpeed","setState","requestAnimationFrame","bind","_this2","trips","TripsLayer","data","getPath","d","getColor","opacity","strokeWidth","trailLength","currentTime","GeoJsonLayer","pickable","stroked","filled","extruded","lineWidthScale","lineWidthMinPixels","getFillColor","getRadius","onHover","_ref","object","x","y","undefined","traceL","traceLine","layers","getLineWidth","getLineColor","_ref2","PathLayer","widthScale","widthMinPixels","positionFormat","getWidth","react_default","a","createElement","esm","controller","_getLayers","dist_esm","width","height","mapboxApiAccessToken","process","React","Component","App","className","components_Deck","Boolean","location","hostname","match","ReactDOM","render","src_components_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.94c82caa.chunk.js","sourcesContent":["import React from 'react';\nimport { FeatureCollection, Geometries, Properties, Feature, Geometry } from '@turf/helpers';\n\nimport DeckGL, { GeoJsonLayer, PathLayer } from 'deck.gl';\nimport { TripsLayer } from '@deck.gl/experimental-layers';\nimport { StaticMap } from 'react-map-gl';\nimport nodeData from '../../data/nodes.json';\nimport pipeData from '../../data/pipes.json';\nimport Tracer from '../../utils/tracer'\nimport { PathCreator } from '../../utils/PathCreator';\n\n// Set your mapbox access token here\nconst MAPBOX_ACCESS_TOKEN = process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n\n// Initial viewport settings\nconst initialViewState = {\n  longitude: 146.732177,\n  latitude: -19.404646,\n  zoom: 10,\n  pitch: 0,\n  bearing: 0\n};\n\n\n\n\n\n\nconst trace = new Tracer(nodeData, pipeData);\nconst path: any[] = []\n\n\n\nfor (let i = 0; i < 1000; i++) {\n  const features: Feature[] = (nodeData as FeatureCollection).features\n  const rndFeature = features[Math.floor(Math.random() * features.length)];\n\n  if (rndFeature.properties && rndFeature.properties.id) {\n    //console.log(rndFeature.properties.id)\n    const constsewerPath = trace.find(rndFeature.properties.id)\n    const sewerPathTime = PathCreator(constsewerPath[0], i)\n    path.push(sewerPathTime)\n  }\n}\n//console.log(path)\n\ntype DeckProps = {\n  loopLength: number,\n  animationSpeed: number\n\n}\n\ninterface DeckState {\n  traceLine?: [{ path: number[][] }],\n  time: number\n}\n\nclass Deck extends React.Component<DeckProps, DeckState> {\n\n  state: Readonly<DeckState> = {\n    time: 0\n  };\n\n  _animationFrame: number | null = null\n\n  componentDidMount() {\n    this._animate(0);\n  }\n\n  componentWillUnmount() {\n    if (this._animationFrame) {\n      window.cancelAnimationFrame(this._animationFrame);\n    }\n  }\n\n  _animate(timeStamp: number) {\n    const {\n      loopLength, // unit corresponds to the timestamp in source data\n      animationSpeed // unit time per second\n    } = this.props;\n    //const timestamp = Date.now();\n    //const loopTime = loopLength / animationSpeed;\n\n    this.setState({\n      //time: ((timestamp % loopTime) / loopTime) * loopLength\n      time: timeStamp / 5\n    });\n    this._animationFrame = window.requestAnimationFrame(this._animate.bind(this));\n  }\n\n  _getLayers() {\n\n    const trips = new TripsLayer({\n      id: 'trips',\n      data: path,\n      getPath: d => d.path,\n      getColor: [255, 0, 0],\n      opacity: 1,\n      strokeWidth: 20,\n      trailLength: 250,\n      currentTime: this.state.time\n    })\n\n\n    const nodes = new GeoJsonLayer({\n      id: 'geojson-node',\n      data: nodeData,\n      pickable: false,\n      stroked: false,\n      filled: true,\n      extruded: true,\n      lineWidthScale: 1,\n      lineWidthMinPixels: 1,\n      getFillColor: [160, 160, 180, 255],\n      getRadius: 1,\n      onHover: ({ object, x, y }) => {\n        if (object !== undefined) {\n          const traceL = trace.find(object.properties.id)\n          this.setState({ traceLine: traceL });\n        }\n      }\n    });\n\n    const pipes = new GeoJsonLayer({\n      id: 'geojson-pipes',\n      data: pipeData,\n      pickable: true,\n      stroked: false,\n      filled: true,\n      extruded: true,\n      lineWidthScale: 1,\n      lineWidthMinPixels: 1,\n      getLineWidth: 1,\n      getLineColor: [60, 0, 0, 50],\n      getRadius: 1,\n      onHover: ({ object, x, y }) => {\n        if (object !== undefined) {\n          const traceL = trace.find(object.properties.id)\n          this.setState({ traceLine: traceL });\n        }\n      }\n    });\n\n    const layers = [\n      //pipes,\n      nodes,\n      trips\n\n    ]\n\n    if (this.state !== null && this.state.traceLine !== null) {\n      layers.push(new PathLayer({\n        id: 'path-layer',\n        data: this.state.traceLine,\n        pickable: true,\n        widthScale: 1,\n        widthMinPixels: 2,\n        positionFormat: `XY`,\n        getPath: d => d.path,\n        getColor: [0, 255, 0, 255],\n        getWidth: d => 5\n      }))\n    }\n\n\n    return layers\n\n  }\n  render() {\n\n\n    return (\n      <DeckGL\n        initialViewState={initialViewState}\n        controller={true}\n        layers={this._getLayers()}\n      >\n        <StaticMap width={\"100%\"} height={\"100%\"} mapboxApiAccessToken={MAPBOX_ACCESS_TOKEN} />\n      </DeckGL>\n    );\n  }\n}\n\nexport default Deck","import { FeatureCollection, Geometries, Properties, Feature, Geometry } from '@turf/helpers';\n\n\nclass Tracer {\n  lookup: { [id: string]: Feature<Geometries, Properties>; }\n  constructor(nodes, pipes) {\n\n    const allFeatures: Feature<Geometry, Properties>[] = nodes.features.concat(pipes.features)\n\n    this.lookup = allFeatures.reduce((obj, item) => {\n      item.properties && (obj[item.properties.id] = item);\n      return obj;\n    }, {});\n\n  }\n  find(id: string): [{ path: number[][] }] {\n\n    const path = [id]\n    let looking = true\n    const geo: number[][] = []\n    while (looking) {\n      const found = this.lookup[path[path.length - 1]]\n\n      if (found !== null && found.properties !== null && found.geometry !== null) {\n\n        const nextObjId = found.properties.ds\n        if (found.properties.ds === null) {\n          looking = false\n        } else {\n          path.push(nextObjId)\n          if (found.geometry.type === \"LineString\") {\n            found.geometry.coordinates.forEach((coor) => {\n              geo.push(coor)\n            })\n          }\n\n        }\n\n      } else {\n        looking = false\n      }\n\n    }\n\n    return [{ path: geo }]\n  }\n\n}\n\nexport default Tracer","\nimport distance from '@turf/distance';\nimport { point } from '@turf/helpers';\n\ninterface SewerPath {\n  path: number[][];\n}\n\ninterface SewerPathTime {\n  path: number[][];\n}\n\nconst PathCreator = (sewerFlow: SewerPath, startValue: number): SewerPathTime => {\n\n  const test = sewerFlow.path.reduce((accumulator: number[][], currentValue, currentIndex, orgPath) => {\n\n    if (currentIndex === 0) {\n      return accumulator.concat([currentValue.concat(startValue)]);\n    } else {\n\n      const previousCoord = orgPath[currentIndex - 1]\n      const from = point(previousCoord)\n      const to = point(currentValue)\n      const dist = distance(from, to, { units: 'kilometers' }) * 1000\n\n      //assuming 1m/s, time is in milliseconds\n      const timeToArrive = accumulator[currentIndex - 1][2] + (dist)\n\n      return accumulator.concat([currentValue.concat(timeToArrive)]);\n\n    }\n\n\n  }, []);\n\n  return { path: test }\n\n}\n\nexport { PathCreator }","import React, { Component } from 'react';\nimport './index.css';\nimport Deck from '../Deck'\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Deck loopLength={13014124} animationSpeed={1} />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}