{"version":3,"sources":["components/Deck/index.tsx","utils/tracer/index.ts","components/App/index.tsx","serviceWorker.ts","index.tsx"],"names":["initialViewState","longitude","latitude","zoom","pitch","bearing","trace","Tracer","nodes","pipes","Object","classCallCheck","this","lookup","allFeatures","features","concat","reduce","obj","item","properties","id","path","looking","geo","found","length","geometry","nextObjId","ds","push","type","coordinates","forEach","coor","nodeData","pipeData","Deck","_this","GeoJsonLayer","data","pickable","stroked","filled","extruded","lineWidthScale","lineWidthMinPixels","getFillColor","getRadius","onHover","_ref","object","x","y","undefined","traceL","find","setState","traceLine","layers","getLineWidth","getLineColor","_ref2","state","PathLayer","widthScale","widthMinPixels","positionFormat","getPath","d","getColor","getWidth","console","log","react_default","a","createElement","esm","controller","_getLayers","dist_esm","width","height","mapboxApiAccessToken","process","React","Component","App","className","components_Deck","Boolean","window","location","hostname","match","ReactDOM","render","src_components_App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.bad0061f.chunk.js","sourcesContent":["import React from 'react';\nimport DeckGL, { GeoJsonLayer, PathLayer } from 'deck.gl';\nimport { StaticMap } from 'react-map-gl';\nimport nodeData from '../../data/nodes.json';\nimport pipeData from '../../data/pipes.json';\nimport Tracer from '../../utils/tracer'\n\n// Set your mapbox access token here\nconst MAPBOX_ACCESS_TOKEN = process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n\n// Initial viewport settings\nconst initialViewState = {\n  longitude: 146.783978,\n  latitude: -19.279793,\n  zoom: 13,\n  pitch: 0,\n  bearing: 0\n};\n\n\nconst trace = new Tracer(nodeData, pipeData);\n\n\ninterface DeckState {\n  traceLine?: [{ path: number[][] }]\n}\n\nclass Deck extends React.Component<{}, DeckState> {\n\n\n  _getLayers() {\n\n\n    const nodes = new GeoJsonLayer({\n      id: 'geojson-node',\n      data: nodeData,\n      pickable: true,\n      stroked: false,\n      filled: true,\n      extruded: true,\n      lineWidthScale: 1,\n      lineWidthMinPixels: 1,\n      getFillColor: [160, 160, 180, 255],\n      getRadius: 1,\n      onHover: ({ object, x, y }) => {\n        if (object !== undefined) {\n          const traceL = trace.find(object.properties.id)\n          this.setState({ traceLine: traceL });\n        }\n      }\n    });\n\n    const pipes = new GeoJsonLayer({\n      id: 'geojson-pipes',\n      data: pipeData,\n      pickable: true,\n      stroked: false,\n      filled: true,\n      extruded: true,\n      lineWidthScale: 1,\n      lineWidthMinPixels: 1,\n      getLineWidth: 1,\n      getLineColor: [180, 0, 0, 200],\n      getRadius: 1,\n      onHover: ({ object, x, y }) => {\n        if (object !== undefined) {\n          const traceL = trace.find(object.properties.id)\n          this.setState({ traceLine: traceL });\n        }\n      }\n    });\n\n    const layers = [\n      pipes,\n      nodes\n\n    ]\n\n    if (this.state !== null && this.state.traceLine !== null) {\n      layers.push(new PathLayer({\n        id: 'path-layer',\n        data: this.state.traceLine,\n        pickable: true,\n        widthScale: 1,\n        widthMinPixels: 2,\n        positionFormat: `XY`,\n        getPath: d => d.path,\n        getColor: [0, 255, 0, 255],\n        getWidth: d => 5\n      }))\n    }\n\n    console.log(layers)\n\n    return layers\n\n  }\n  render() {\n\n\n    return (\n      <DeckGL\n        initialViewState={initialViewState}\n        controller={true}\n        layers={this._getLayers()}\n      >\n        <StaticMap width={\"100%\"} height={\"100%\"} mapboxApiAccessToken={MAPBOX_ACCESS_TOKEN} />\n      </DeckGL>\n    );\n  }\n}\n\nexport default Deck","import { FeatureCollection, Geometries, Properties, Feature, Geometry } from '@turf/helpers';\n\n\nclass Tracer {\n  lookup: { [id: string]: Feature<Geometries, Properties>; }\n  constructor(nodes, pipes) {\n\n    const allFeatures: Feature<Geometry, Properties>[] = nodes.features.concat(pipes.features)\n\n    this.lookup = allFeatures.reduce((obj, item) => {\n      item.properties && (obj[item.properties.id] = item);\n      return obj;\n    }, {});\n\n  }\n  find(id: string): [{ path: number[][] }] {\n\n    const path = [id]\n    let looking = true\n    const geo: number[][] = []\n    while (looking) {\n      const found = this.lookup[path[path.length - 1]]\n\n      if (found !== null && found.properties !== null && found.geometry !== null) {\n\n        const nextObjId = found.properties.ds\n        if (found.properties.ds === null) {\n          looking = false\n        } else {\n          path.push(nextObjId)\n          if (found.geometry.type === \"LineString\") {\n            found.geometry.coordinates.forEach((coor) => {\n              geo.push(coor)\n            })\n          }\n\n        }\n\n      } else {\n        looking = false\n      }\n\n    }\n\n    return [{ path: geo }]\n  }\n\n}\n\nexport default Tracer","import React, { Component } from 'react';\nimport './index.css';\nimport Deck from '../Deck'\n\nclass App extends Component {\n  render() {\n    return (\n      <div className=\"App\">\n        <Deck />\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './components/App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}